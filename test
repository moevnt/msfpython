#!/usr/bin/env python3

import subprocess
import os
import datetime
import shutil
import sys
import argparse

# Python wrapper for msfvenom

EXTERNAL_PROGRAM_NAME = "msfvenom"

def run_external_program(): 

    # Argument parsing
    parser = argparse.ArgumentParser(description="A python wrapper for MSFVenom")
    parser.add_argument("-p","--payload", help="Payload to use")
    parser.add_argument("-lp", "--LocalPort", help="The local port of your msfconsole")
    parser.add_argument("-lh", "--LocalHost", help="The IP of your msfconsole")
    parser.add_argument("-f", "--format", help="the format of the created file")
    parser.add_argument("-o", "--output", help="the name of the created file")
    parser.add_argument("-oh", "--Otherhelp", help="displays the msfvenom help page", action="store_true")
    args = parser.parse_args()

    # Check if msfvenom is installed on the system
    if shutil.which(EXTERNAL_PROGRAM_NAME) is None:
        print("Error: The external program'{EXTERNAL_PROGRAM_NAME}' was not found.")
        sys.exit(1)

    # Prep the msfvenom command and the directory that 
    # payloads will be auto-saved to. Create directory if it does not exist
    command_to_run = [EXTERNAL_PROGRAM_NAME] + sys.argv[1:]
    save_directory = "/home/kali/Desktop/payloads/"
    if not os.path.exists(save_directory):
        os.mkdir(save_directory)
        print("Directory Created")

    # Run the msfvenom command
    try:
        subprocess.run(command_to_run, check=True, capture_output=False, text=True)
        
        #-otherhelp
        if args.otherhelp:
            print(subprocess.run("msfvenom -h", capture_output=True))

        # Removes everything prior to powershell.exe from a psh-cmd command 
        if sys.argv[6] == "psh-cmd":
            init_file = open(sys.argv[8], 'r')
            payload = init_file.read()
            cleaned = payload[30:]
            init_file.close()
            full_path = os.path.join(save_directory, sys.argv[8])
            fin_file = open(full_path, 'w+')
            fin_file.write(cleaned)
            fin_file.close()
            os.remove(sys.argv[8])

        else: 
            src_file = sys.argv[8]
            dst_file = os.path.join(save_directory, sys.argv[8])
            shutil.copy(src_file, dst_file)
            os.remove(sys.argv[8])

        # Creates a metadata file that saves the inputs for the command and timestamps the file
        date = f"{datetime.datetime.now().strftime('%d-%B-%H%M')}_"+sys.argv[8]+".txt"
        full_path = os.path.join(save_directory, date)
        meta_file = open(full_path, 'w+')
        meta_file.write(sys.argv[2]+'\n'+sys.argv[3]+'\n'+sys.argv[4]+'\n'+sys.argv[6]+'\n'+sys.argv[8])
        meta_file.close()

    except subprocess.CalledProcessError as e:
        print("External program failed with return code {e.returncode}")
        sys.exit(e.returncode)

# Main method
if __name__ == "__main__":
    run_external_program()
